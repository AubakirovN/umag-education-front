import "./chunk-AJSRI63H.js";
import {
  applyMiddleware,
  combineReducers,
  compose,
  createStore
} from "./chunk-QSZVOITA.js";
import {
  es_default
} from "./chunk-YMU2OWCY.js";
import "./chunk-TVOPUOW3.js";
import "./chunk-HM4MQYWN.js";

// node_modules/@reduxjs/toolkit/src/devtoolsExtension.ts
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0)
    return void 0;
  if (typeof arguments[0] === "object")
    return compose;
  return compose.apply(null, arguments);
};
var devToolsEnhancer = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {
  return function(noop) {
    return noop;
  };
};

// node_modules/@reduxjs/toolkit/src/isPlainObject.ts
function isPlainObject(value) {
  if (typeof value !== "object" || value === null)
    return false;
  let proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  let baseProto = proto;
  while (Object.getPrototypeOf(baseProto) !== null) {
    baseProto = Object.getPrototypeOf(baseProto);
  }
  return proto === baseProto;
}

// node_modules/@reduxjs/toolkit/src/tsHelpers.ts
var hasMatchFunction = (v) => {
  return v && typeof v.match === "function";
};

// node_modules/@reduxjs/toolkit/src/createAction.ts
function isActionCreator(action) {
  return typeof action === "function" && "type" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it
  hasMatchFunction(action);
}

// node_modules/@reduxjs/toolkit/src/actionCreatorInvariantMiddleware.ts
function getMessage(type) {
  const splitType = type ? `${type}`.split("/") : [];
  const actionName = splitType[splitType.length - 1] || "actionCreator";
  return `Detected an action creator with type "${type || "unknown"}" being dispatched. 
Make sure you're calling the action creator before dispatching, i.e. \`dispatch(${actionName}())\` instead of \`dispatch(${actionName})\`. This is necessary even if the action has no payload.`;
}
function createActionCreatorInvariantMiddleware(options = {}) {
  if (false) {
    return () => (next) => (action) => next(action);
  }
  const { isActionCreator: isActionCreator2 = isActionCreator } = options;
  return () => (next) => (action) => {
    if (isActionCreator2(action)) {
      console.warn(getMessage(action.type));
    }
    return next(action);
  };
}

// node_modules/@reduxjs/toolkit/src/utils.ts
function getTimeMeasureUtils(maxDelay, fnName) {
  let elapsed = 0;
  return {
    measureTime(fn) {
      const started = Date.now();
      try {
        return fn();
      } finally {
        const finished = Date.now();
        elapsed += finished - started;
      }
    },
    warnIfExceeded() {
      if (elapsed > maxDelay) {
        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. 
If your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.
It is disabled in production builds, so you don't need to worry about that.`);
      }
    }
  };
}
var MiddlewareArray = class _MiddlewareArray extends Array {
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, _MiddlewareArray.prototype);
  }
  static get [Symbol.species]() {
    return _MiddlewareArray;
  }
  concat(...arr) {
    return super.concat.apply(this, arr);
  }
  prepend(...arr) {
    if (arr.length === 1 && Array.isArray(arr[0])) {
      return new _MiddlewareArray(...arr[0].concat(this));
    }
    return new _MiddlewareArray(...arr.concat(this));
  }
};
var EnhancerArray = class _EnhancerArray extends Array {
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, _EnhancerArray.prototype);
  }
  static get [Symbol.species]() {
    return _EnhancerArray;
  }
  concat(...arr) {
    return super.concat.apply(this, arr);
  }
  prepend(...arr) {
    if (arr.length === 1 && Array.isArray(arr[0])) {
      return new _EnhancerArray(...arr[0].concat(this));
    }
    return new _EnhancerArray(...arr.concat(this));
  }
};

// node_modules/@reduxjs/toolkit/src/immutableStateInvariantMiddleware.ts
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  throw new Error(`${prefix}: ${message || ""}`);
}
function stringify(obj, serializer, indent, decycler) {
  return JSON.stringify(obj, getSerialize(serializer, decycler), indent);
}
function getSerialize(serializer, decycler) {
  let stack = [], keys = [];
  if (!decycler)
    decycler = function(_, value) {
      if (stack[0] === value)
        return "[Circular ~]";
      return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
    };
  return function(key, value) {
    if (stack.length > 0) {
      var thisPos = stack.indexOf(this);
      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
      if (~stack.indexOf(value))
        value = decycler.call(this, key, value);
    } else
      stack.push(value);
    return serializer == null ? value : serializer.call(this, key, value);
  };
}
function isImmutableDefault(value) {
  return typeof value !== "object" || value == null || Object.isFrozen(value);
}
function trackForMutations(isImmutable, ignorePaths, obj) {
  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
  return {
    detectMutations() {
      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
    }
  };
}
function trackProperties(isImmutable, ignorePaths = [], obj, path = "", checkedObjects = /* @__PURE__ */ new Set()) {
  const tracked = { value: obj };
  if (!isImmutable(obj) && !checkedObjects.has(obj)) {
    checkedObjects.add(obj);
    tracked.children = {};
    for (const key in obj) {
      const childPath = path ? path + "." + key : key;
      if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
        continue;
      }
      tracked.children[key] = trackProperties(
        isImmutable,
        ignorePaths,
        obj[key],
        childPath
      );
    }
  }
  return tracked;
}
function detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = "") {
  const prevObj = trackedProperty ? trackedProperty.value : void 0;
  const sameRef = prevObj === obj;
  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {
    return { wasMutated: true, path };
  }
  if (isImmutable(prevObj) || isImmutable(obj)) {
    return { wasMutated: false };
  }
  const keysToDetect = {};
  for (let key in trackedProperty.children) {
    keysToDetect[key] = true;
  }
  for (let key in obj) {
    keysToDetect[key] = true;
  }
  const hasIgnoredPaths = ignoredPaths.length > 0;
  for (let key in keysToDetect) {
    const nestedPath = path ? path + "." + key : key;
    if (hasIgnoredPaths) {
      const hasMatches = ignoredPaths.some((ignored) => {
        if (ignored instanceof RegExp) {
          return ignored.test(nestedPath);
        }
        return nestedPath === ignored;
      });
      if (hasMatches) {
        continue;
      }
    }
    const result = detectMutations(
      isImmutable,
      ignoredPaths,
      trackedProperty.children[key],
      obj[key],
      sameRef,
      nestedPath
    );
    if (result.wasMutated) {
      return result;
    }
  }
  return { wasMutated: false };
}
function createImmutableStateInvariantMiddleware(options = {}) {
  if (false) {
    return () => (next) => (action) => next(action);
  }
  let {
    isImmutable = isImmutableDefault,
    ignoredPaths,
    warnAfter = 32,
    ignore
  } = options;
  ignoredPaths = ignoredPaths || ignore;
  const track = trackForMutations.bind(null, isImmutable, ignoredPaths);
  return ({ getState }) => {
    let state = getState();
    let tracker = track(state);
    let result;
    return (next) => (action) => {
      const measureUtils = getTimeMeasureUtils(
        warnAfter,
        "ImmutableStateInvariantMiddleware"
      );
      measureUtils.measureTime(() => {
        state = getState();
        result = tracker.detectMutations();
        tracker = track(state);
        invariant(
          !result.wasMutated,
          `A state mutation was detected between dispatches, in the path '${result.path || ""}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`
        );
      });
      const dispatchedAction = next(action);
      measureUtils.measureTime(() => {
        state = getState();
        result = tracker.detectMutations();
        tracker = track(state);
        result.wasMutated && invariant(
          !result.wasMutated,
          `A state mutation was detected inside a dispatch, in the path: ${result.path || ""}. Take a look at the reducer(s) handling the action ${stringify(
            action
          )}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`
        );
      });
      measureUtils.warnIfExceeded();
      return dispatchedAction;
    };
  };
}

// node_modules/@reduxjs/toolkit/src/serializableStateInvariantMiddleware.ts
function isPlain(val) {
  const type = typeof val;
  return val == null || type === "string" || type === "boolean" || type === "number" || Array.isArray(val) || isPlainObject(val);
}
function findNonSerializableValue(value, path = "", isSerializable = isPlain, getEntries, ignoredPaths = [], cache) {
  let foundNestedSerializable;
  if (!isSerializable(value)) {
    return {
      keyPath: path || "<root>",
      value
    };
  }
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (cache == null ? void 0 : cache.has(value))
    return false;
  const entries = getEntries != null ? getEntries(value) : Object.entries(value);
  const hasIgnoredPaths = ignoredPaths.length > 0;
  for (const [key, nestedValue] of entries) {
    const nestedPath = path ? path + "." + key : key;
    if (hasIgnoredPaths) {
      const hasMatches = ignoredPaths.some((ignored) => {
        if (ignored instanceof RegExp) {
          return ignored.test(nestedPath);
        }
        return nestedPath === ignored;
      });
      if (hasMatches) {
        continue;
      }
    }
    if (!isSerializable(nestedValue)) {
      return {
        keyPath: nestedPath,
        value: nestedValue
      };
    }
    if (typeof nestedValue === "object") {
      foundNestedSerializable = findNonSerializableValue(
        nestedValue,
        nestedPath,
        isSerializable,
        getEntries,
        ignoredPaths,
        cache
      );
      if (foundNestedSerializable) {
        return foundNestedSerializable;
      }
    }
  }
  if (cache && isNestedFrozen(value))
    cache.add(value);
  return false;
}
function isNestedFrozen(value) {
  if (!Object.isFrozen(value))
    return false;
  for (const nestedValue of Object.values(value)) {
    if (typeof nestedValue !== "object" || nestedValue === null)
      continue;
    if (!isNestedFrozen(nestedValue))
      return false;
  }
  return true;
}
function createSerializableStateInvariantMiddleware(options = {}) {
  if (false) {
    return () => (next) => (action) => next(action);
  }
  const {
    isSerializable = isPlain,
    getEntries,
    ignoredActions = [],
    ignoredActionPaths = ["meta.arg", "meta.baseQueryMeta"],
    ignoredPaths = [],
    warnAfter = 32,
    ignoreState = false,
    ignoreActions = false,
    disableCache = false
  } = options;
  const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;
  return (storeAPI) => (next) => (action) => {
    const result = next(action);
    const measureUtils = getTimeMeasureUtils(
      warnAfter,
      "SerializableStateInvariantMiddleware"
    );
    if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {
      measureUtils.measureTime(() => {
        const foundActionNonSerializableValue = findNonSerializableValue(
          action,
          "",
          isSerializable,
          getEntries,
          ignoredActionPaths,
          cache
        );
        if (foundActionNonSerializableValue) {
          const { keyPath, value } = foundActionNonSerializableValue;
          console.error(
            `A non-serializable value was detected in an action, in the path: \`${keyPath}\`. Value:`,
            value,
            "\nTake a look at the logic that dispatched this action: ",
            action,
            "\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)",
            "\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)"
          );
        }
      });
    }
    if (!ignoreState) {
      measureUtils.measureTime(() => {
        const state = storeAPI.getState();
        const foundStateNonSerializableValue = findNonSerializableValue(
          state,
          "",
          isSerializable,
          getEntries,
          ignoredPaths,
          cache
        );
        if (foundStateNonSerializableValue) {
          const { keyPath, value } = foundStateNonSerializableValue;
          console.error(
            `A non-serializable value was detected in the state, in the path: \`${keyPath}\`. Value:`,
            value,
            `
Take a look at the reducer(s) handling this action type: ${action.type}.
(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`
          );
        }
      });
      measureUtils.warnIfExceeded();
    }
    return result;
  };
}

// node_modules/@reduxjs/toolkit/src/getDefaultMiddleware.ts
function isBoolean(x) {
  return typeof x === "boolean";
}
function curryGetDefaultMiddleware() {
  return function curriedGetDefaultMiddleware(options) {
    return getDefaultMiddleware(options);
  };
}
function getDefaultMiddleware(options = {}) {
  const {
    thunk = true,
    immutableCheck = true,
    serializableCheck = true,
    actionCreatorCheck = true
  } = options;
  let middlewareArray = new MiddlewareArray();
  if (thunk) {
    if (isBoolean(thunk)) {
      middlewareArray.push(es_default);
    } else {
      middlewareArray.push(
        es_default.withExtraArgument(thunk.extraArgument)
      );
    }
  }
  if (true) {
    if (immutableCheck) {
      let immutableOptions = {};
      if (!isBoolean(immutableCheck)) {
        immutableOptions = immutableCheck;
      }
      middlewareArray.unshift(
        createImmutableStateInvariantMiddleware(immutableOptions)
      );
    }
    if (serializableCheck) {
      let serializableOptions = {};
      if (!isBoolean(serializableCheck)) {
        serializableOptions = serializableCheck;
      }
      middlewareArray.push(
        createSerializableStateInvariantMiddleware(serializableOptions)
      );
    }
    if (actionCreatorCheck) {
      let actionCreatorOptions = {};
      if (!isBoolean(actionCreatorCheck)) {
        actionCreatorOptions = actionCreatorCheck;
      }
      middlewareArray.unshift(
        createActionCreatorInvariantMiddleware(actionCreatorOptions)
      );
    }
  }
  return middlewareArray;
}

// node_modules/@reduxjs/toolkit/src/configureStore.ts
var IS_PRODUCTION = false;
function configureStore(options) {
  const curriedGetDefaultMiddleware = curryGetDefaultMiddleware();
  const {
    reducer = void 0,
    middleware = curriedGetDefaultMiddleware(),
    devTools = true,
    preloadedState = void 0,
    enhancers = void 0
  } = options || {};
  let rootReducer;
  if (typeof reducer === "function") {
    rootReducer = reducer;
  } else if (isPlainObject(reducer)) {
    rootReducer = combineReducers(reducer);
  } else {
    throw new Error(
      '"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'
    );
  }
  let finalMiddleware = middleware;
  if (typeof finalMiddleware === "function") {
    finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);
    if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {
      throw new Error(
        "when using a middleware builder function, an array of middleware must be returned"
      );
    }
  }
  if (!IS_PRODUCTION && finalMiddleware.some((item) => typeof item !== "function")) {
    throw new Error(
      "each middleware provided to configureStore must be a function"
    );
  }
  const middlewareEnhancer = applyMiddleware(...finalMiddleware);
  let finalCompose = compose;
  if (devTools) {
    finalCompose = composeWithDevTools({
      // Enable capture of stack traces for dispatched Redux actions
      trace: !IS_PRODUCTION,
      ...typeof devTools === "object" && devTools
    });
  }
  const defaultEnhancers = new EnhancerArray(middlewareEnhancer);
  let storeEnhancers = defaultEnhancers;
  if (Array.isArray(enhancers)) {
    storeEnhancers = [middlewareEnhancer, ...enhancers];
  } else if (typeof enhancers === "function") {
    storeEnhancers = enhancers(defaultEnhancers);
  }
  const composedEnhancer = finalCompose(...storeEnhancers);
  return createStore(rootReducer, preloadedState, composedEnhancer);
}
export {
  configureStore
};
//# sourceMappingURL=@reduxjs_toolkit_src_configureStore.js.map
